<html>
<head>
<title>searchtools.js</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #808080;}
.s1 { color: #a9b7c6;}
.s2 { color: #6a8759;}
.s3 { color: #cc7832;}
.s4 { color: #6897bb;}
.s5 { color: #4646f1;}
</style>
</head>
<body bgcolor="#2b2b2b">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
searchtools.js</font>
</center></td></tr></table>
<pre><span class="s0">/* 
 * searchtools.js 
 * ~~~~~~~~~~~~~~~~ 
 * 
 * Sphinx JavaScript utilities for the full-text search. 
 * 
 * :copyright: Copyright 2007-2023 by the Sphinx team, see AUTHORS. 
 * :license: BSD, see LICENSE for details. 
 * 
 */</span>
<span class="s2">&quot;use strict&quot;</span><span class="s1">;</span>

<span class="s0">/** 
 * Simple result scoring code. 
 */</span>
<span class="s3">if </span><span class="s1">(</span><span class="s3">typeof </span><span class="s1">Scorer === </span><span class="s2">&quot;undefined&quot;</span><span class="s1">) {</span>
  <span class="s3">var </span><span class="s1">Scorer = {</span>
    <span class="s0">// Implement the following function to further tweak the score for each result</span>
    <span class="s0">// The function takes a result array [docname, title, anchor, descr, score, filename]</span>
    <span class="s0">// and returns the new score.</span>
    <span class="s0">/* 
    score: result =&gt; { 
      const [docname, title, anchor, descr, score, filename] = result 
      return score 
    }, 
    */</span>

    <span class="s0">// query matches the full name of an object</span>
    <span class="s1">objNameMatch: </span><span class="s4">11</span><span class="s1">,</span>
    <span class="s0">// or matches in the last dotted part of the object name</span>
    <span class="s1">objPartialMatch: </span><span class="s4">6</span><span class="s1">,</span>
    <span class="s0">// Additive scores depending on the priority of the object</span>
    <span class="s1">objPrio: {</span>
      <span class="s4">0</span><span class="s1">: </span><span class="s4">15</span><span class="s1">, </span><span class="s0">// used to be importantResults</span>
      <span class="s4">1</span><span class="s1">: </span><span class="s4">5</span><span class="s1">, </span><span class="s0">// used to be objectResults</span>
      <span class="s4">2</span><span class="s1">: -</span><span class="s4">5</span><span class="s1">, </span><span class="s0">// used to be unimportantResults</span>
    <span class="s1">},</span>
    <span class="s0">//  Used when the priority is not in the mapping.</span>
    <span class="s1">objPrioDefault: </span><span class="s4">0</span><span class="s1">,</span>

    <span class="s0">// query found in title</span>
    <span class="s1">title: </span><span class="s4">15</span><span class="s1">,</span>
    <span class="s1">partialTitle: </span><span class="s4">7</span><span class="s1">,</span>
    <span class="s0">// query found in terms</span>
    <span class="s1">term: </span><span class="s4">5</span><span class="s1">,</span>
    <span class="s1">partialTerm: </span><span class="s4">2</span><span class="s1">,</span>
  <span class="s1">};</span>
<span class="s1">}</span>

<span class="s1">const _removeChildren = (element) =&gt; {</span>
  <span class="s3">while </span><span class="s1">(element &amp;&amp; element.lastChild) element.removeChild(element.lastChild);</span>
<span class="s1">};</span>

<span class="s0">/** 
 * See https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Regular_Expressions#escaping 
 */</span>
<span class="s1">const _escapeRegExp = (string) =&gt;</span>
  <span class="s1">string.replace(/[.*+\-?^${}()|[\]\\]/g, </span><span class="s2">&quot;</span><span class="s5">\\</span><span class="s2">$&amp;&quot;</span><span class="s1">); </span><span class="s0">// $&amp; means the whole matched string</span>

<span class="s1">const _displayItem = (item, searchTerms) =&gt; {</span>
  <span class="s1">const docBuilder = DOCUMENTATION_OPTIONS.BUILDER;</span>
  <span class="s1">const docUrlRoot = DOCUMENTATION_OPTIONS.URL_ROOT;</span>
  <span class="s1">const docFileSuffix = DOCUMENTATION_OPTIONS.FILE_SUFFIX;</span>
  <span class="s1">const docLinkSuffix = DOCUMENTATION_OPTIONS.LINK_SUFFIX;</span>
  <span class="s1">const showSearchSummary = DOCUMENTATION_OPTIONS.SHOW_SEARCH_SUMMARY;</span>

  <span class="s1">const [docName, title, anchor, descr, score, _filename] = item;</span>

  <span class="s1">let listItem = document.createElement(</span><span class="s2">&quot;li&quot;</span><span class="s1">);</span>
  <span class="s1">let requestUrl;</span>
  <span class="s1">let linkUrl;</span>
  <span class="s3">if </span><span class="s1">(docBuilder === </span><span class="s2">&quot;dirhtml&quot;</span><span class="s1">) {</span>
    <span class="s0">// dirhtml builder</span>
    <span class="s1">let dirname = docName + </span><span class="s2">&quot;/&quot;</span><span class="s1">;</span>
    <span class="s3">if </span><span class="s1">(dirname.match(/\/index\/$/))</span>
      <span class="s1">dirname = dirname.substring(</span><span class="s4">0</span><span class="s1">, dirname.length - </span><span class="s4">6</span><span class="s1">);</span>
    <span class="s3">else if </span><span class="s1">(dirname === </span><span class="s2">&quot;index/&quot;</span><span class="s1">) dirname = </span><span class="s2">&quot;&quot;</span><span class="s1">;</span>
    <span class="s1">requestUrl = docUrlRoot + dirname;</span>
    <span class="s1">linkUrl = requestUrl;</span>
  <span class="s1">} </span><span class="s3">else </span><span class="s1">{</span>
    <span class="s0">// normal html builders</span>
    <span class="s1">requestUrl = docUrlRoot + docName + docFileSuffix;</span>
    <span class="s1">linkUrl = docName + docLinkSuffix;</span>
  <span class="s1">}</span>
  <span class="s1">let linkEl = listItem.appendChild(document.createElement(</span><span class="s2">&quot;a&quot;</span><span class="s1">));</span>
  <span class="s1">linkEl.href = linkUrl + anchor;</span>
  <span class="s1">linkEl.dataset.score = score;</span>
  <span class="s1">linkEl.innerHTML = title;</span>
  <span class="s3">if </span><span class="s1">(descr)</span>
    <span class="s1">listItem.appendChild(document.createElement(</span><span class="s2">&quot;span&quot;</span><span class="s1">)).innerHTML =</span>
      <span class="s2">&quot; (&quot; </span><span class="s1">+ descr + </span><span class="s2">&quot;)&quot;</span><span class="s1">;</span>
  <span class="s3">else if </span><span class="s1">(showSearchSummary)</span>
    <span class="s1">fetch(requestUrl)</span>
      <span class="s1">.then((responseData) =&gt; responseData.text())</span>
      <span class="s1">.then((data) =&gt; {</span>
        <span class="s3">if </span><span class="s1">(data)</span>
          <span class="s1">listItem.appendChild(</span>
            <span class="s1">Search.makeSearchSummary(data, searchTerms)</span>
          <span class="s1">);</span>
      <span class="s1">});</span>
  <span class="s1">Search.output.appendChild(listItem);</span>
<span class="s1">};</span>
<span class="s1">const _finishSearch = (resultCount) =&gt; {</span>
  <span class="s1">Search.stopPulse();</span>
  <span class="s1">Search.title.innerText = _(</span><span class="s2">&quot;Search Results&quot;</span><span class="s1">);</span>
  <span class="s3">if </span><span class="s1">(!resultCount)</span>
    <span class="s1">Search.status.innerText = Documentation.gettext(</span>
      <span class="s2">&quot;Your search did not match any documents. Please make sure that all words are spelled correctly and that you've selected enough categories.&quot;</span>
    <span class="s1">);</span>
  <span class="s3">else</span>
    <span class="s1">Search.status.innerText = _(</span>
      <span class="s1">`Search finished, found ${resultCount} page(s) matching the search query.`</span>
    <span class="s1">);</span>
<span class="s1">};</span>
<span class="s1">const _displayNextItem = (</span>
  <span class="s1">results,</span>
  <span class="s1">resultCount,</span>
  <span class="s1">searchTerms</span>
<span class="s1">) =&gt; {</span>
  <span class="s0">// results left, load the summary and display it</span>
  <span class="s0">// this is intended to be dynamic (don't sub resultsCount)</span>
  <span class="s3">if </span><span class="s1">(results.length) {</span>
    <span class="s1">_displayItem(results.pop(), searchTerms);</span>
    <span class="s1">setTimeout(</span>
      <span class="s1">() =&gt; _displayNextItem(results, resultCount, searchTerms),</span>
      <span class="s4">5</span>
    <span class="s1">);</span>
  <span class="s1">}</span>
  <span class="s0">// search finished, update title and status message</span>
  <span class="s3">else </span><span class="s1">_finishSearch(resultCount);</span>
<span class="s1">};</span>

<span class="s0">/** 
 * Default splitQuery function. Can be overridden in ``sphinx.search`` with a 
 * custom function per language. 
 * 
 * The regular expression works by splitting the string on consecutive characters 
 * that are not Unicode letters, numbers, underscores, or emoji characters. 
 * This is the same as ``\W+`` in Python, preserving the surrogate pair area. 
 */</span>
<span class="s3">if </span><span class="s1">(</span><span class="s3">typeof </span><span class="s1">splitQuery === </span><span class="s2">&quot;undefined&quot;</span><span class="s1">) {</span>
  <span class="s3">var </span><span class="s1">splitQuery = (query) =&gt; query</span>
      <span class="s1">.split(/[^\p{Letter}\p{Number}_\p{Emoji_Presentation}]+/gu)</span>
      <span class="s1">.filter(term =&gt; term)  </span><span class="s0">// remove remaining empty strings</span>
<span class="s1">}</span>

<span class="s0">/** 
 * Search Module 
 */</span>
<span class="s1">const Search = {</span>
  <span class="s1">_index: </span><span class="s3">null</span><span class="s1">,</span>
  <span class="s1">_queued_query: </span><span class="s3">null</span><span class="s1">,</span>
  <span class="s1">_pulse_status: -</span><span class="s4">1</span><span class="s1">,</span>

  <span class="s1">htmlToText: (htmlString) =&gt; {</span>
    <span class="s1">const htmlElement = </span><span class="s3">new </span><span class="s1">DOMParser().parseFromString(htmlString, </span><span class="s2">'text/html'</span><span class="s1">);</span>
    <span class="s1">htmlElement.querySelectorAll(</span><span class="s2">&quot;.headerlink&quot;</span><span class="s1">).forEach((el) =&gt; { el.remove() });</span>
    <span class="s1">const docContent = htmlElement.querySelector(</span><span class="s2">'[role=&quot;main&quot;]'</span><span class="s1">);</span>
    <span class="s3">if </span><span class="s1">(docContent !== undefined) </span><span class="s3">return </span><span class="s1">docContent.textContent;</span>
    <span class="s1">console.warn(</span>
      <span class="s2">&quot;Content block not found. Sphinx search tries to obtain it via '[role=main]'. Could you check your theme or template.&quot;</span>
    <span class="s1">);</span>
    <span class="s3">return </span><span class="s2">&quot;&quot;</span><span class="s1">;</span>
  <span class="s1">},</span>

  <span class="s1">init: () =&gt; {</span>
    <span class="s1">const query = </span><span class="s3">new </span><span class="s1">URLSearchParams(window.location.search).get(</span><span class="s2">&quot;q&quot;</span><span class="s1">);</span>
    <span class="s1">document</span>
      <span class="s1">.querySelectorAll(</span><span class="s2">'input[name=&quot;q&quot;]'</span><span class="s1">)</span>
      <span class="s1">.forEach((el) =&gt; (el.value = query));</span>
    <span class="s3">if </span><span class="s1">(query) Search.performSearch(query);</span>
  <span class="s1">},</span>

  <span class="s1">loadIndex: (url) =&gt;</span>
    <span class="s1">(document.body.appendChild(document.createElement(</span><span class="s2">&quot;script&quot;</span><span class="s1">)).src = url),</span>

  <span class="s1">setIndex: (index) =&gt; {</span>
    <span class="s1">Search._index = index;</span>
    <span class="s3">if </span><span class="s1">(Search._queued_query !== </span><span class="s3">null</span><span class="s1">) {</span>
      <span class="s1">const query = Search._queued_query;</span>
      <span class="s1">Search._queued_query = </span><span class="s3">null</span><span class="s1">;</span>
      <span class="s1">Search.query(query);</span>
    <span class="s1">}</span>
  <span class="s1">},</span>

  <span class="s1">hasIndex: () =&gt; Search._index !== </span><span class="s3">null</span><span class="s1">,</span>

  <span class="s1">deferQuery: (query) =&gt; (Search._queued_query = query),</span>

  <span class="s1">stopPulse: () =&gt; (Search._pulse_status = -</span><span class="s4">1</span><span class="s1">),</span>

  <span class="s1">startPulse: () =&gt; {</span>
    <span class="s3">if </span><span class="s1">(Search._pulse_status &gt;= </span><span class="s4">0</span><span class="s1">) </span><span class="s3">return</span><span class="s1">;</span>

    <span class="s1">const pulse = () =&gt; {</span>
      <span class="s1">Search._pulse_status = (Search._pulse_status + </span><span class="s4">1</span><span class="s1">) % </span><span class="s4">4</span><span class="s1">;</span>
      <span class="s1">Search.dots.innerText = </span><span class="s2">&quot;.&quot;</span><span class="s1">.repeat(Search._pulse_status);</span>
      <span class="s3">if </span><span class="s1">(Search._pulse_status &gt;= </span><span class="s4">0</span><span class="s1">) window.setTimeout(pulse, </span><span class="s4">500</span><span class="s1">);</span>
    <span class="s1">};</span>
    <span class="s1">pulse();</span>
  <span class="s1">},</span>

  <span class="s0">/** 
   * perform a search for something (or wait until index is loaded) 
   */</span>
  <span class="s1">performSearch: (query) =&gt; {</span>
    <span class="s0">// create the required interface elements</span>
    <span class="s1">const searchText = document.createElement(</span><span class="s2">&quot;h2&quot;</span><span class="s1">);</span>
    <span class="s1">searchText.textContent = _(</span><span class="s2">&quot;Searching&quot;</span><span class="s1">);</span>
    <span class="s1">const searchSummary = document.createElement(</span><span class="s2">&quot;p&quot;</span><span class="s1">);</span>
    <span class="s1">searchSummary.classList.add(</span><span class="s2">&quot;search-summary&quot;</span><span class="s1">);</span>
    <span class="s1">searchSummary.innerText = </span><span class="s2">&quot;&quot;</span><span class="s1">;</span>
    <span class="s1">const searchList = document.createElement(</span><span class="s2">&quot;ul&quot;</span><span class="s1">);</span>
    <span class="s1">searchList.classList.add(</span><span class="s2">&quot;search&quot;</span><span class="s1">);</span>

    <span class="s1">const out = document.getElementById(</span><span class="s2">&quot;search-results&quot;</span><span class="s1">);</span>
    <span class="s1">Search.title = out.appendChild(searchText);</span>
    <span class="s1">Search.dots = Search.title.appendChild(document.createElement(</span><span class="s2">&quot;span&quot;</span><span class="s1">));</span>
    <span class="s1">Search.status = out.appendChild(searchSummary);</span>
    <span class="s1">Search.output = out.appendChild(searchList);</span>

    <span class="s1">const searchProgress = document.getElementById(</span><span class="s2">&quot;search-progress&quot;</span><span class="s1">);</span>
    <span class="s0">// Some themes don't use the search progress node</span>
    <span class="s3">if </span><span class="s1">(searchProgress) {</span>
      <span class="s1">searchProgress.innerText = _(</span><span class="s2">&quot;Preparing search...&quot;</span><span class="s1">);</span>
    <span class="s1">}</span>
    <span class="s1">Search.startPulse();</span>

    <span class="s0">// index already loaded, the browser was quick!</span>
    <span class="s3">if </span><span class="s1">(Search.hasIndex()) Search.query(query);</span>
    <span class="s3">else </span><span class="s1">Search.deferQuery(query);</span>
  <span class="s1">},</span>

  <span class="s0">/** 
   * execute search (requires search index to be loaded) 
   */</span>
  <span class="s1">query: (query) =&gt; {</span>
    <span class="s1">const filenames = Search._index.filenames;</span>
    <span class="s1">const docNames = Search._index.docnames;</span>
    <span class="s1">const titles = Search._index.titles;</span>
    <span class="s1">const allTitles = Search._index.alltitles;</span>
    <span class="s1">const indexEntries = Search._index.indexentries;</span>

    <span class="s0">// stem the search terms and add them to the correct list</span>
    <span class="s1">const stemmer = </span><span class="s3">new </span><span class="s1">Stemmer();</span>
    <span class="s1">const searchTerms = </span><span class="s3">new </span><span class="s1">Set();</span>
    <span class="s1">const excludedTerms = </span><span class="s3">new </span><span class="s1">Set();</span>
    <span class="s1">const highlightTerms = </span><span class="s3">new </span><span class="s1">Set();</span>
    <span class="s1">const objectTerms = </span><span class="s3">new </span><span class="s1">Set(splitQuery(query.toLowerCase().trim()));</span>
    <span class="s1">splitQuery(query.trim()).forEach((queryTerm) =&gt; {</span>
      <span class="s1">const queryTermLower = queryTerm.toLowerCase();</span>

      <span class="s0">// maybe skip this &quot;word&quot;</span>
      <span class="s0">// stopwords array is from language_data.js</span>
      <span class="s3">if </span><span class="s1">(</span>
        <span class="s1">stopwords.indexOf(queryTermLower) !== -</span><span class="s4">1 </span><span class="s1">||</span>
        <span class="s1">queryTerm.match(/^\d+$/)</span>
      <span class="s1">)</span>
        <span class="s3">return</span><span class="s1">;</span>

      <span class="s0">// stem the word</span>
      <span class="s1">let word = stemmer.stemWord(queryTermLower);</span>
      <span class="s0">// select the correct list</span>
      <span class="s3">if </span><span class="s1">(word[</span><span class="s4">0</span><span class="s1">] === </span><span class="s2">&quot;-&quot;</span><span class="s1">) excludedTerms.add(word.substr(</span><span class="s4">1</span><span class="s1">));</span>
      <span class="s3">else </span><span class="s1">{</span>
        <span class="s1">searchTerms.add(word);</span>
        <span class="s1">highlightTerms.add(queryTermLower);</span>
      <span class="s1">}</span>
    <span class="s1">});</span>

    <span class="s3">if </span><span class="s1">(SPHINX_HIGHLIGHT_ENABLED) {  </span><span class="s0">// set in sphinx_highlight.js</span>
      <span class="s1">localStorage.setItem(</span><span class="s2">&quot;sphinx_highlight_terms&quot;</span><span class="s1">, [...highlightTerms].join(</span><span class="s2">&quot; &quot;</span><span class="s1">))</span>
    <span class="s1">}</span>

    <span class="s0">// console.debug(&quot;SEARCH: searching for:&quot;);</span>
    <span class="s0">// console.info(&quot;required: &quot;, [...searchTerms]);</span>
    <span class="s0">// console.info(&quot;excluded: &quot;, [...excludedTerms]);</span>

    <span class="s0">// array of [docname, title, anchor, descr, score, filename]</span>
    <span class="s1">let results = [];</span>
    <span class="s1">_removeChildren(document.getElementById(</span><span class="s2">&quot;search-progress&quot;</span><span class="s1">));</span>

    <span class="s1">const queryLower = query.toLowerCase();</span>
    <span class="s3">for </span><span class="s1">(const [title, foundTitles] of Object.entries(allTitles)) {</span>
      <span class="s3">if </span><span class="s1">(title.toLowerCase().includes(queryLower) &amp;&amp; (queryLower.length &gt;= title.length/</span><span class="s4">2</span><span class="s1">)) {</span>
        <span class="s3">for </span><span class="s1">(const [file, id] of foundTitles) {</span>
          <span class="s1">let score = Math.round(</span><span class="s4">100 </span><span class="s1">* queryLower.length / title.length)</span>
          <span class="s1">results.push([</span>
            <span class="s1">docNames[file],</span>
            <span class="s1">titles[file] !== title ? `${titles[file]} &gt; ${title}` : title,</span>
            <span class="s1">id !== </span><span class="s3">null </span><span class="s1">? </span><span class="s2">&quot;#&quot; </span><span class="s1">+ id : </span><span class="s2">&quot;&quot;</span><span class="s1">,</span>
            <span class="s3">null</span><span class="s1">,</span>
            <span class="s1">score,</span>
            <span class="s1">filenames[file],</span>
          <span class="s1">]);</span>
        <span class="s1">}</span>
      <span class="s1">}</span>
    <span class="s1">}</span>

    <span class="s0">// search for explicit entries in index directives</span>
    <span class="s3">for </span><span class="s1">(const [entry, foundEntries] of Object.entries(indexEntries)) {</span>
      <span class="s3">if </span><span class="s1">(entry.includes(queryLower) &amp;&amp; (queryLower.length &gt;= entry.length/</span><span class="s4">2</span><span class="s1">)) {</span>
        <span class="s3">for </span><span class="s1">(const [file, id] of foundEntries) {</span>
          <span class="s1">let score = Math.round(</span><span class="s4">100 </span><span class="s1">* queryLower.length / entry.length)</span>
          <span class="s1">results.push([</span>
            <span class="s1">docNames[file],</span>
            <span class="s1">titles[file],</span>
            <span class="s1">id ? </span><span class="s2">&quot;#&quot; </span><span class="s1">+ id : </span><span class="s2">&quot;&quot;</span><span class="s1">,</span>
            <span class="s3">null</span><span class="s1">,</span>
            <span class="s1">score,</span>
            <span class="s1">filenames[file],</span>
          <span class="s1">]);</span>
        <span class="s1">}</span>
      <span class="s1">}</span>
    <span class="s1">}</span>

    <span class="s0">// lookup as object</span>
    <span class="s1">objectTerms.forEach((term) =&gt;</span>
      <span class="s1">results.push(...Search.performObjectSearch(term, objectTerms))</span>
    <span class="s1">);</span>

    <span class="s0">// lookup as search terms in fulltext</span>
    <span class="s1">results.push(...Search.performTermsSearch(searchTerms, excludedTerms));</span>

    <span class="s0">// let the scorer override scores with a custom scoring function</span>
    <span class="s3">if </span><span class="s1">(Scorer.score) results.forEach((item) =&gt; (item[</span><span class="s4">4</span><span class="s1">] = Scorer.score(item)));</span>

    <span class="s0">// now sort the results by score (in opposite order of appearance, since the</span>
    <span class="s0">// display function below uses pop() to retrieve items) and then</span>
    <span class="s0">// alphabetically</span>
    <span class="s1">results.sort((a, b) =&gt; {</span>
      <span class="s1">const leftScore = a[</span><span class="s4">4</span><span class="s1">];</span>
      <span class="s1">const rightScore = b[</span><span class="s4">4</span><span class="s1">];</span>
      <span class="s3">if </span><span class="s1">(leftScore === rightScore) {</span>
        <span class="s0">// same score: sort alphabetically</span>
        <span class="s1">const leftTitle = a[</span><span class="s4">1</span><span class="s1">].toLowerCase();</span>
        <span class="s1">const rightTitle = b[</span><span class="s4">1</span><span class="s1">].toLowerCase();</span>
        <span class="s3">if </span><span class="s1">(leftTitle === rightTitle) </span><span class="s3">return </span><span class="s4">0</span><span class="s1">;</span>
        <span class="s3">return </span><span class="s1">leftTitle &gt; rightTitle ? -</span><span class="s4">1 </span><span class="s1">: </span><span class="s4">1</span><span class="s1">; </span><span class="s0">// inverted is intentional</span>
      <span class="s1">}</span>
      <span class="s3">return </span><span class="s1">leftScore &gt; rightScore ? </span><span class="s4">1 </span><span class="s1">: -</span><span class="s4">1</span><span class="s1">;</span>
    <span class="s1">});</span>

    <span class="s0">// remove duplicate search results</span>
    <span class="s0">// note the reversing of results, so that in the case of duplicates, the highest-scoring entry is kept</span>
    <span class="s1">let seen = </span><span class="s3">new </span><span class="s1">Set();</span>
    <span class="s1">results = results.reverse().reduce((acc, result) =&gt; {</span>
      <span class="s1">let resultStr = result.slice(</span><span class="s4">0</span><span class="s1">, </span><span class="s4">4</span><span class="s1">).concat([result[</span><span class="s4">5</span><span class="s1">]]).map(v =&gt; String(v)).join(</span><span class="s2">','</span><span class="s1">);</span>
      <span class="s3">if </span><span class="s1">(!seen.has(resultStr)) {</span>
        <span class="s1">acc.push(result);</span>
        <span class="s1">seen.add(resultStr);</span>
      <span class="s1">}</span>
      <span class="s3">return </span><span class="s1">acc;</span>
    <span class="s1">}, []);</span>

    <span class="s1">results = results.reverse();</span>

    <span class="s0">// for debugging</span>
    <span class="s0">//Search.lastresults = results.slice();  // a copy</span>
    <span class="s0">// console.info(&quot;search results:&quot;, Search.lastresults);</span>

    <span class="s0">// print the results</span>
    <span class="s1">_displayNextItem(results, results.length, searchTerms);</span>
  <span class="s1">},</span>

  <span class="s0">/** 
   * search for object names 
   */</span>
  <span class="s1">performObjectSearch: (object, objectTerms) =&gt; {</span>
    <span class="s1">const filenames = Search._index.filenames;</span>
    <span class="s1">const docNames = Search._index.docnames;</span>
    <span class="s1">const objects = Search._index.objects;</span>
    <span class="s1">const objNames = Search._index.objnames;</span>
    <span class="s1">const titles = Search._index.titles;</span>

    <span class="s1">const results = [];</span>

    <span class="s1">const objectSearchCallback = (prefix, match) =&gt; {</span>
      <span class="s1">const name = match[</span><span class="s4">4</span><span class="s1">]</span>
      <span class="s1">const fullname = (prefix ? prefix + </span><span class="s2">&quot;.&quot; </span><span class="s1">: </span><span class="s2">&quot;&quot;</span><span class="s1">) + name;</span>
      <span class="s1">const fullnameLower = fullname.toLowerCase();</span>
      <span class="s3">if </span><span class="s1">(fullnameLower.indexOf(object) &lt; </span><span class="s4">0</span><span class="s1">) </span><span class="s3">return</span><span class="s1">;</span>

      <span class="s1">let score = </span><span class="s4">0</span><span class="s1">;</span>
      <span class="s1">const parts = fullnameLower.split(</span><span class="s2">&quot;.&quot;</span><span class="s1">);</span>

      <span class="s0">// check for different match types: exact matches of full name or</span>
      <span class="s0">// &quot;last name&quot; (i.e. last dotted part)</span>
      <span class="s3">if </span><span class="s1">(fullnameLower === object || parts.slice(-</span><span class="s4">1</span><span class="s1">)[</span><span class="s4">0</span><span class="s1">] === object)</span>
        <span class="s1">score += Scorer.objNameMatch;</span>
      <span class="s3">else if </span><span class="s1">(parts.slice(-</span><span class="s4">1</span><span class="s1">)[</span><span class="s4">0</span><span class="s1">].indexOf(object) &gt; -</span><span class="s4">1</span><span class="s1">)</span>
        <span class="s1">score += Scorer.objPartialMatch; </span><span class="s0">// matches in last name</span>

      <span class="s1">const objName = objNames[match[</span><span class="s4">1</span><span class="s1">]][</span><span class="s4">2</span><span class="s1">];</span>
      <span class="s1">const title = titles[match[</span><span class="s4">0</span><span class="s1">]];</span>

      <span class="s0">// If more than one term searched for, we require other words to be</span>
      <span class="s0">// found in the name/title/description</span>
      <span class="s1">const otherTerms = </span><span class="s3">new </span><span class="s1">Set(objectTerms);</span>
      <span class="s1">otherTerms.</span><span class="s3">delete</span><span class="s1">(object);</span>
      <span class="s3">if </span><span class="s1">(otherTerms.size &gt; </span><span class="s4">0</span><span class="s1">) {</span>
        <span class="s1">const haystack = `${prefix} ${name} ${objName} ${title}`.toLowerCase();</span>
        <span class="s3">if </span><span class="s1">(</span>
          <span class="s1">[...otherTerms].some((otherTerm) =&gt; haystack.indexOf(otherTerm) &lt; </span><span class="s4">0</span><span class="s1">)</span>
        <span class="s1">)</span>
          <span class="s3">return</span><span class="s1">;</span>
      <span class="s1">}</span>

      <span class="s1">let anchor = match[</span><span class="s4">3</span><span class="s1">];</span>
      <span class="s3">if </span><span class="s1">(anchor === </span><span class="s2">&quot;&quot;</span><span class="s1">) anchor = fullname;</span>
      <span class="s3">else if </span><span class="s1">(anchor === </span><span class="s2">&quot;-&quot;</span><span class="s1">) anchor = objNames[match[</span><span class="s4">1</span><span class="s1">]][</span><span class="s4">1</span><span class="s1">] + </span><span class="s2">&quot;-&quot; </span><span class="s1">+ fullname;</span>

      <span class="s1">const descr = objName + _(</span><span class="s2">&quot;, in &quot;</span><span class="s1">) + title;</span>

      <span class="s0">// add custom score for some objects according to scorer</span>
      <span class="s3">if </span><span class="s1">(Scorer.objPrio.hasOwnProperty(match[</span><span class="s4">2</span><span class="s1">]))</span>
        <span class="s1">score += Scorer.objPrio[match[</span><span class="s4">2</span><span class="s1">]];</span>
      <span class="s3">else </span><span class="s1">score += Scorer.objPrioDefault;</span>

      <span class="s1">results.push([</span>
        <span class="s1">docNames[match[</span><span class="s4">0</span><span class="s1">]],</span>
        <span class="s1">fullname,</span>
        <span class="s2">&quot;#&quot; </span><span class="s1">+ anchor,</span>
        <span class="s1">descr,</span>
        <span class="s1">score,</span>
        <span class="s1">filenames[match[</span><span class="s4">0</span><span class="s1">]],</span>
      <span class="s1">]);</span>
    <span class="s1">};</span>
    <span class="s1">Object.keys(objects).forEach((prefix) =&gt;</span>
      <span class="s1">objects[prefix].forEach((array) =&gt;</span>
        <span class="s1">objectSearchCallback(prefix, array)</span>
      <span class="s1">)</span>
    <span class="s1">);</span>
    <span class="s3">return </span><span class="s1">results;</span>
  <span class="s1">},</span>

  <span class="s0">/** 
   * search for full-text terms in the index 
   */</span>
  <span class="s1">performTermsSearch: (searchTerms, excludedTerms) =&gt; {</span>
    <span class="s0">// prepare search</span>
    <span class="s1">const terms = Search._index.terms;</span>
    <span class="s1">const titleTerms = Search._index.titleterms;</span>
    <span class="s1">const filenames = Search._index.filenames;</span>
    <span class="s1">const docNames = Search._index.docnames;</span>
    <span class="s1">const titles = Search._index.titles;</span>

    <span class="s1">const scoreMap = </span><span class="s3">new </span><span class="s1">Map();</span>
    <span class="s1">const fileMap = </span><span class="s3">new </span><span class="s1">Map();</span>

    <span class="s0">// perform the search on the required terms</span>
    <span class="s1">searchTerms.forEach((word) =&gt; {</span>
      <span class="s1">const files = [];</span>
      <span class="s1">const arr = [</span>
        <span class="s1">{ files: terms[word], score: Scorer.term },</span>
        <span class="s1">{ files: titleTerms[word], score: Scorer.title },</span>
      <span class="s1">];</span>
      <span class="s0">// add support for partial matches</span>
      <span class="s3">if </span><span class="s1">(word.length &gt; </span><span class="s4">2</span><span class="s1">) {</span>
        <span class="s1">const escapedWord = _escapeRegExp(word);</span>
        <span class="s1">Object.keys(terms).forEach((term) =&gt; {</span>
          <span class="s3">if </span><span class="s1">(term.match(escapedWord) &amp;&amp; !terms[word])</span>
            <span class="s1">arr.push({ files: terms[term], score: Scorer.partialTerm });</span>
        <span class="s1">});</span>
        <span class="s1">Object.keys(titleTerms).forEach((term) =&gt; {</span>
          <span class="s3">if </span><span class="s1">(term.match(escapedWord) &amp;&amp; !titleTerms[word])</span>
            <span class="s1">arr.push({ files: titleTerms[word], score: Scorer.partialTitle });</span>
        <span class="s1">});</span>
      <span class="s1">}</span>

      <span class="s0">// no match but word was a required one</span>
      <span class="s3">if </span><span class="s1">(arr.every((record) =&gt; record.files === undefined)) </span><span class="s3">return</span><span class="s1">;</span>

      <span class="s0">// found search word in contents</span>
      <span class="s1">arr.forEach((record) =&gt; {</span>
        <span class="s3">if </span><span class="s1">(record.files === undefined) </span><span class="s3">return</span><span class="s1">;</span>

        <span class="s1">let recordFiles = record.files;</span>
        <span class="s3">if </span><span class="s1">(recordFiles.length === undefined) recordFiles = [recordFiles];</span>
        <span class="s1">files.push(...recordFiles);</span>

        <span class="s0">// set score for the word in each file</span>
        <span class="s1">recordFiles.forEach((file) =&gt; {</span>
          <span class="s3">if </span><span class="s1">(!scoreMap.has(file)) scoreMap.set(file, {});</span>
          <span class="s1">scoreMap.get(file)[word] = record.score;</span>
        <span class="s1">});</span>
      <span class="s1">});</span>

      <span class="s0">// create the mapping</span>
      <span class="s1">files.forEach((file) =&gt; {</span>
        <span class="s3">if </span><span class="s1">(fileMap.has(file) &amp;&amp; fileMap.get(file).indexOf(word) === -</span><span class="s4">1</span><span class="s1">)</span>
          <span class="s1">fileMap.get(file).push(word);</span>
        <span class="s3">else </span><span class="s1">fileMap.set(file, [word]);</span>
      <span class="s1">});</span>
    <span class="s1">});</span>

    <span class="s0">// now check if the files don't contain excluded terms</span>
    <span class="s1">const results = [];</span>
    <span class="s3">for </span><span class="s1">(const [file, wordList] of fileMap) {</span>
      <span class="s0">// check if all requirements are matched</span>

      <span class="s0">// as search terms with length &lt; 3 are discarded</span>
      <span class="s1">const filteredTermCount = [...searchTerms].filter(</span>
        <span class="s1">(term) =&gt; term.length &gt; </span><span class="s4">2</span>
      <span class="s1">).length;</span>
      <span class="s3">if </span><span class="s1">(</span>
        <span class="s1">wordList.length !== searchTerms.size &amp;&amp;</span>
        <span class="s1">wordList.length !== filteredTermCount</span>
      <span class="s1">)</span>
        <span class="s3">continue</span><span class="s1">;</span>

      <span class="s0">// ensure that none of the excluded terms is in the search result</span>
      <span class="s3">if </span><span class="s1">(</span>
        <span class="s1">[...excludedTerms].some(</span>
          <span class="s1">(term) =&gt;</span>
            <span class="s1">terms[term] === file ||</span>
            <span class="s1">titleTerms[term] === file ||</span>
            <span class="s1">(terms[term] || []).includes(file) ||</span>
            <span class="s1">(titleTerms[term] || []).includes(file)</span>
        <span class="s1">)</span>
      <span class="s1">)</span>
        <span class="s3">break</span><span class="s1">;</span>

      <span class="s0">// select one (max) score for the file.</span>
      <span class="s1">const score = Math.max(...wordList.map((w) =&gt; scoreMap.get(file)[w]));</span>
      <span class="s0">// add result to the result list</span>
      <span class="s1">results.push([</span>
        <span class="s1">docNames[file],</span>
        <span class="s1">titles[file],</span>
        <span class="s2">&quot;&quot;</span><span class="s1">,</span>
        <span class="s3">null</span><span class="s1">,</span>
        <span class="s1">score,</span>
        <span class="s1">filenames[file],</span>
      <span class="s1">]);</span>
    <span class="s1">}</span>
    <span class="s3">return </span><span class="s1">results;</span>
  <span class="s1">},</span>

  <span class="s0">/** 
   * helper function to return a node containing the 
   * search summary for a given text. keywords is a list 
   * of stemmed words. 
   */</span>
  <span class="s1">makeSearchSummary: (htmlText, keywords) =&gt; {</span>
    <span class="s1">const text = Search.htmlToText(htmlText);</span>
    <span class="s3">if </span><span class="s1">(text === </span><span class="s2">&quot;&quot;</span><span class="s1">) </span><span class="s3">return null</span><span class="s1">;</span>

    <span class="s1">const textLower = text.toLowerCase();</span>
    <span class="s1">const actualStartPosition = [...keywords]</span>
      <span class="s1">.map((k) =&gt; textLower.indexOf(k.toLowerCase()))</span>
      <span class="s1">.filter((i) =&gt; i &gt; -</span><span class="s4">1</span><span class="s1">)</span>
      <span class="s1">.slice(-</span><span class="s4">1</span><span class="s1">)[</span><span class="s4">0</span><span class="s1">];</span>
    <span class="s1">const startWithContext = Math.max(actualStartPosition - </span><span class="s4">120</span><span class="s1">, </span><span class="s4">0</span><span class="s1">);</span>

    <span class="s1">const top = startWithContext === </span><span class="s4">0 </span><span class="s1">? </span><span class="s2">&quot;&quot; </span><span class="s1">: </span><span class="s2">&quot;...&quot;</span><span class="s1">;</span>
    <span class="s1">const tail = startWithContext + </span><span class="s4">240 </span><span class="s1">&lt; text.length ? </span><span class="s2">&quot;...&quot; </span><span class="s1">: </span><span class="s2">&quot;&quot;</span><span class="s1">;</span>

    <span class="s1">let summary = document.createElement(</span><span class="s2">&quot;p&quot;</span><span class="s1">);</span>
    <span class="s1">summary.classList.add(</span><span class="s2">&quot;context&quot;</span><span class="s1">);</span>
    <span class="s1">summary.textContent = top + text.substr(startWithContext, </span><span class="s4">240</span><span class="s1">).trim() + tail;</span>

    <span class="s3">return </span><span class="s1">summary;</span>
  <span class="s1">},</span>
<span class="s1">};</span>

<span class="s1">_ready(Search.init);</span>
</pre>
</body>
</html>